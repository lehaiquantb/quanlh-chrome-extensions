{"version":3,"file":"extension-pack/build/background.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://qcx/./src/shared/helper.common.ts","webpack://qcx/./src/shared/index.ts","webpack://qcx/./src/shared/services/storage.ts","webpack://qcx/webpack/bootstrap","webpack://qcx/webpack/runtime/define property getters","webpack://qcx/webpack/runtime/hasOwnProperty shorthand","webpack://qcx/webpack/runtime/make namespace object","webpack://qcx/./src/background.ts"],"sourcesContent":["/* eslint-disable no-eval */\nexport const createElementByText = (textHTML = \"\") => {\n    const template = document.createElement(\"template\");\n    textHTML = textHTML.trim(); // Never return a text node of whitespace as the result\n    template.innerHTML = textHTML;\n    return template.content.firstElementChild;\n};\nexport function copyToClipboard(text) {\n    try {\n        const elem = document.createElement(\"textarea\");\n        elem.value = text;\n        document.body.appendChild(elem);\n        elem.select();\n        document.execCommand(\"copy\");\n        document.body.removeChild(elem);\n        return true;\n    }\n    catch (error) {\n        return false;\n    }\n}\nexport const isEmptyString = (str) => {\n    return str === \"\" || str === null || str === undefined;\n};\nexport function globalVarIsExist(varName) {\n    try {\n        return !!window?.[varName] ?? eval(`typeof ${varName}`) !== \"undefined\";\n    }\n    catch (error) {\n        // console.log('varIsExist', error);\n        return false;\n    }\n}\nexport function getGlobalVar(varName) {\n    try {\n        return globalVarIsExist(varName) ? window?.[varName] ?? eval(varName) : undefined;\n    }\n    catch (error) {\n        return undefined;\n    }\n}\nexport function getChrome() {\n    return getGlobalVar(\"chrome\");\n}\nexport async function getCurrentTab() {\n    return (await getChrome()?.tabs?.query?.({\n        active: true,\n        currentWindow: true,\n    }))?.[0];\n}\nexport function tryEval(str, context) {\n    try {\n        const contextString = `\n                const { ${Object.keys(context ?? {}).join(\",\")} } = context ?? {};\n            `;\n        return eval(contextString + str);\n    }\n    catch (error) {\n        console.error(\"tryEval =>\", error);\n        return undefined;\n    }\n}\nexport function getRuntimeEnvironment() {\n    const envs = [];\n    try {\n        const chrome = getChrome();\n        if (!chrome) {\n            envs.push(\"browser\");\n        }\n        if (typeof chrome?.extension !== \"undefined\") {\n            console.log(\"Script đang chạy trong background.\");\n            envs.push(\"background\");\n        }\n        else if (typeof chrome?.runtime !== \"undefined\") {\n            console.log(\"Script đang chạy trong background hoặc event page.\");\n            envs.push(\"background_or_event_page\");\n        }\n        const popupExists = chrome?.extension?.getViews?.({ type: \"popup\" })?.length > 0;\n        if (popupExists) {\n            console.log(\"Script đang chạy trong popup.\");\n            envs.push(\"popup\");\n        }\n        const isContentScript = window?.location?.href?.startsWith?.(\"http\");\n        const backgroundPageExists = typeof chrome?.extension?.getBackgroundPage?.() !== \"undefined\";\n        if (isContentScript) {\n            console.log(\"Script đang chạy trong content script.\");\n            envs.push(\"content_script\");\n        }\n        if (backgroundPageExists) {\n            console.log(\"Script đang chạy trong content script và background.\");\n            envs.push(\"content_script_and_background\");\n        }\n        return envs;\n    }\n    catch (error) {\n        console.log(\"getRuntimeEnvironment\", error);\n        envs.push(\"unknown\");\n        return envs;\n    }\n}\nexport const parseJson = (value) => {\n    try {\n        return JSON.parse(typeof value === \"string\" ? value : JSON.stringify(value));\n    }\n    catch (error) {\n        console.log(\"Error in parseJson\", error);\n        return undefined;\n    }\n};\nexport const isMatchWebsite = (matchRegexUrls) => {\n    return matchRegexUrls?.some((url) => new RegExp(url).test(window.location.href));\n};\nexport const injectReplaceCSS = (() => {\n    const style = document.createElement(\"style\");\n    document.head.append(style);\n    return (cssText) => {\n        try {\n            style.textContent = cssText;\n        }\n        catch (error) {\n            console.log(`Error in injectReplaceCSS ${error}`);\n        }\n    };\n})();\nexport const waitUntil = async (conditionCb, interval = 100, maxAttempts = 5000) => {\n    let attempts = 0;\n    // eslint-disable-next-line no-async-promise-executor\n    return new Promise(async (resolve, reject) => {\n        try {\n            if (await conditionCb()) {\n                return resolve(null);\n            }\n            const intervalId = setInterval(async function () {\n                attempts++;\n                try {\n                    const a = await conditionCb();\n                    if (a || attempts >= maxAttempts) {\n                        resolve(null);\n                        clearInterval(intervalId);\n                        return null;\n                    }\n                }\n                catch (error) {\n                    reject(error);\n                    clearInterval(intervalId);\n                }\n            }, interval);\n        }\n        catch (error) {\n            console.log(\"Error in waitUntil\", error);\n            reject(error);\n        }\n    });\n};\nexport const delay = (ts) => {\n    return new Promise((resolve) => {\n        setTimeout(() => {\n            resolve(null);\n        }, ts);\n    });\n};\nexport function addScript(src) {\n    const s = document.createElement(\"script\");\n    s.setAttribute(\"src\", src);\n    document.body.appendChild(s);\n}\nexport function getManifestVersion() {\n    return chrome.runtime.getManifest().manifest_version;\n}\nconst HELPER = {\n    createElementByText,\n    copyToClipboard,\n    isEmptyString,\n    globalVarIsExist,\n    getGlobalVar,\n    getChrome,\n    getCurrentTab,\n    tryEval,\n    getRuntimeEnvironment,\n    parseJson,\n    isMatchWebsite,\n    injectReplaceCSS,\n    waitUntil,\n    delay,\n    addScript,\n};\nexport default HELPER;\n","import { getChrome } from \"./helper.common\";\nexport var ECommandId;\n(function (ECommandId) {\n    ECommandId[\"DOWNLOAD_WORD\"] = \"download-word\";\n    ECommandId[\"DOWNLOAD_PDF\"] = \"download-pdf\";\n    ECommandId[\"TEST_COMMAND\"] = \"test-command\";\n    ECommandId[\"GET_RECAPTCHA_TOKEN\"] = \"get-reCAPTCHA-token\";\n})(ECommandId || (ECommandId = {}));\nexport * from \"./helper.common\";\nexport * from \"./services/storage\";\nexport const chrome = getChrome();\n","import { chrome, parseJson } from \"@/shared\";\nexport class Storage {\n    type = \"chromeStorage\";\n    constructor(type = \"chromeStorage\") {\n        this.type = type;\n        // switch (this.type) {\n        //   case \"localStorage\":\n        //     break\n        //   case \"chromeStorage\":\n        //     this.onChange()\n        //     break\n        // }\n    }\n    async set(key, value) {\n        try {\n            switch (this.type) {\n                case \"localStorage\":\n                    // eslint-disable-next-line no-case-declarations\n                    const oldValue = parseJson(localStorage)?.[key];\n                    localStorage.setItem(key, value);\n                    // eslint-disable-next-line no-case-declarations\n                    const event = new CustomEvent(\"itemInserted\", {\n                        detail: {\n                            oldValue,\n                            newValue: value,\n                            key,\n                        },\n                    });\n                    document.dispatchEvent(event);\n                    break;\n                case \"chromeStorage\":\n                    await chrome?.storage?.local?.set?.({ [key]: value });\n                    break;\n            }\n        }\n        catch (error) {\n            console.log(\"error set\", error);\n        }\n    }\n    async get(key) {\n        try {\n            switch (this.type) {\n                case \"localStorage\":\n                    return localStorage.getItem(key);\n                case \"chromeStorage\":\n                    return (await chrome?.storage?.local?.get?.(key))?.[key];\n            }\n        }\n        catch (error) {\n            console.log(\"error get\", error);\n            return undefined;\n        }\n    }\n    onChange(cb) {\n        switch (this.type) {\n            case \"localStorage\":\n                document.addEventListener(\"itemInserted\", (event) => {\n                    const { key, oldValue, newValue } = event?.detail ?? {};\n                    // eslint-disable-next-line node/no-callback-literal\n                    cb?.({\n                        [key]: {\n                            oldValue,\n                            newValue,\n                        },\n                    });\n                }, false);\n                break;\n            case \"chromeStorage\":\n                chrome?.storage?.onChanged?.addListener?.((changes, namespace) => {\n                    // console.log(\"changes\", changes, namespace)\n                    if (namespace === \"local\") {\n                        cb?.(changes);\n                    }\n                });\n        }\n    }\n    async clear() {\n        switch (this.type) {\n            case \"localStorage\":\n                localStorage.clear();\n                break;\n            case \"chromeStorage\":\n                await chrome?.storage?.local?.clear?.();\n                break;\n        }\n    }\n}\nexport const storageChrome = new Storage(\"chromeStorage\");\nexport const storageLocal = new Storage(\"localStorage\");\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { getManifestVersion } from \"./shared\";\nconst color = \"#3aa757\";\nconsole.log(\"Background script running...\", chrome);\nchrome.runtime.onInstalled.addListener(async () => {\n    chrome.storage.sync.set({ color });\n    console.log(\"Default background color set to %cgreen\", `color: ${color}`);\n});\n// const getTabs = () => {\n//   return new Promise<chrome.tabs.Tab[]>((resolve) => {\n//     chrome.tabs.query({ currentWindow: true, active: true }, function (tabs) {\n//       resolve(tabs)\n//     })\n//   })\n// }\n// ;(async () => {\n//   const tab = (await getTabs())?.[0]\n//   console.log(\"Tab clicked!\", tab.url, tab.id, tab)\n//   const tabId = tab?.id\n//   if (tabId) {\n//     chrome.scripting.executeScript({\n//       target: {\n//         tabId,\n//       },\n//       // files: [\"assets/js/swagger-ui-bundle.min.js\"],\n//       world: \"MAIN\",\n//       func: () => {\n//         console.log(\"Script injected!\")\n//       },\n//     })\n//   }\n// })()\n// chrome.tabs.onActivated.addListener((activeInfo) => {\n//   chrome.tabs.query(\n//     { active: true, currentWindow: true, windowId: chrome.windows.WINDOW_ID_CURRENT },\n//     function (tabs) {\n//       const url = tabs[0].url\n//       console.log(url)\n//     },\n//   )\n// })\nif (getManifestVersion() === 2) {\n    // chrome.webRequest.onBeforeRequest.addListener(\n    //   (request) => {\n    //     console.log(request)\n    //   },\n    //   { urls: [\"https://*/*\", \"http://*/*\"] },\n    // )\n}\nelse {\n    // rules for V3 \n}\n"],"names":[],"sourceRoot":""}